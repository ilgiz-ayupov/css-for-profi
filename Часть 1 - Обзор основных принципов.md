В Части 1 подробно рассматриваются наиболее важные составляющие CSS - __каскадность__, __относительные единицы__ и __блочная модель__. 

## Глава 1. Каскадность, специфичность и наследование.

__В этой главе:__
- Четыре компонента каскадности.
- Разница между каскадностью и наследованием.
- Управление стилями, применяемые к элементам.
- Распространенные недоразумения с сокращенными объявлениями.

### 1.1 Каскадность
__Каскадность CSS__ - это механизм, благодаря которому к HTML-документу может применяться более чем одно правило CSS. 

__Каскадное значение__ -  объявление, которое "побеждают"каскадность.

Правила могут исходить из различных источников: из внешней и внутренней таблицы стилей, от механизма наследования, от родительских элементов, от классов и ID, от селектора тега, от атрибута `style` и т.д. 

Когда правила конфликтуют, для устранения проблемы нужно учесть три показателя.
1. `Источник стилей` - место их разположения. Ваши стили накладываюся на стили браузера, применяемые по умолчанию.
2. `Специчность селекторов` - то, какие селекторы имеют приоритет над другими.
3. `Исходный порядок` - порядок, в котором стили объявляются в таблице стилей.

#### 1.1.1 Источник стилей
Источники стилей:
1. `Браузерные` - созданные браузером таблицы стилей
2. `Авторские` - созданные вами таблицы стилей

#### 1.1.2 Специфичность селекторов
__Браузер оценивает специфичность в два этапа__:
1. `Встроенные в HTML-код (Inline-стили)` - объявления, задаваемые в вашей таблице стилей или теге `<style>`. Во встроенных стилях нет селектора, потому что они действуют непосредственно на сам элемент.
	```html
	<li>
		<a href="/specials" class="featured" style="background-color: orange;">
		Акции !
		</a>
	</li>
	```
1. `Стили, применяемые с помощью селекторов` - __специфичность селекторов__.

__Примечание__:
 - __Селекторы псевдоклассов__ (например, `:hover`) и __селекторы атрибутов__ (например, `[type="input"]`) специфичны в той же степени, что и селектор класса. __Универсальный селектор (`*`) и комбинаторы (`>, +, ~`) не влияют на специфичность__.
	 
__Система приоритов:__

#### 1.1.3 Исходный порядок

- Порядок имеет значение: стили, указанные позже, переоределяют ранние стили с той же специфичностью. Если два подобных стиля или более одновременно относятся к одному и тому же элементу, __последний__ переопределяет предыдущие. 

##### - Правильное форматирование ссылок:

```CSS
	a:link { // Непосещенная
		color: blue;
		text-decoration: none;
	}

	a:visited {  // Посещенная
		color: purple;	
	}

	a:hover { // Наведение
		text-decoration: underline;
	}

	a:active { // Активная
		color: red;
	}
```

#### 1.1.4 Два правила каскадности

1. _Не используйте идентификаторы в селекторе_. Даже один идентификатор усиливает специфичность. Когда требуется переопределить селектор, может не оказаться другого идентификатора, который реально задействавать, поэтому вам придётся скопировать исходный селектор и добавить другой класс, чтобы отличить его от того, который вы пытаетесь переопределить.
2. _Не используйте аннотацию !important_. Её ещё труднее переопределить, чем идентификатор, и, как только вы её примените, нужно будет добавлять её каждый раз, когда захотите переопределить исходное объяление, и тогда все равно придётся иметь дело со специфичностью.

### Ключевое слово important
Объявление со словом !important рассмотривается как источник с более высоким приоритетом. Далее стили перечислены в порядке убывания приоритета.
1. Важные авторские стили.
2. Авторские стили
3. Браузерные стили

### Немного про JavaScript
Создавая модуль JavaScript для последующего распространения (например, пакет NPM), __не задействуйте стили, встроенные в JavaScript__, когда этого можно избежать. Если вы это сделаете, разработчики, применяющие вам пакет, будут вынуждены либо принять ваши стили без изменений, либо использовать аннотацию !important для каждого свойства, которое она захотят изменить.

Вместо этого добавьте в пакет таблицу стилей. Если ваш компонент должен динамически менять стили,  почти всегда предпочтительнее задействовать JavaScript для добавления и удаления классов элементов. Кроме того, пользователи смогут отредактировать таблицк стилей как им нравится, не сталкиваясь с конфликтами специфичности.

### 1.2 Наследование
__Наследование в CSS__ - это механизм, с помощью которого значения свойств элемента-родителя передаются его элементам-потомкам.


### 1.3 Специальные значения

#### 1.3.1 Ключевое слово inherit
Позволяет унаследовать стиль, когда каскадное значение замещает его.

#### 1.3.2 Ключевое слово initial 
Позволяет сбросить стили у элемента, приводя их к значению по умолчанию.

__Примечание__
-   Объявление `dispay: initial` эквивалентно коду `dispay: inline`. Оно не будет определено как `display: block` независимо от того, к элементу какого типа вы его применяете. Это потому, что ключевое слово initial выполняет сброс до начального значения для свойства, а не элемента, а `inline` - значение по умолчанию для свойства `display`.


### 1.4 Сокращенная запись свойств
__Сокращенная запись свойств__ - это присвоение значений нескольких свойств одновременно.

- `background` - сокращенная запись свойств фона `background-color`, `background-image`, `background-size`, `background-repeat`, `background-position`, `background-origin`, `background-chip` и `background-attachment`.
- `border` - сокращенная запись свойств `border-width`, `border-style` и `border-color`
- `border-width` - сокращенная запись свойств `top`, `right`, `bottom` и `left` ширины границ.

__Внимание !__
- Большинство сокращенниый записей свойств позволяют опускать определенные значения и указывать только нужные. Однако важно знать, что пропущенные свойства все равно задаются - им присваивается начатьные значения.

### 1.4.1 Порядок записи сокращенных значений
- По часовой стрелке - применяется для `margin`, `padding` и некоторых свойств границ, которые определяют значения для каждой из четырёх сторон элементов.
- Горизонтально, вертикально - описывает `x`  и `y` кординаты элемента


## Глава 2. Работа с относительными единицами

__В этой главе__:
- Гибкость относительных единиц
- Как использовать единицы: rem и em
- Применение экранных единиц: vw и vh
- Введение в CSS переменные

### 2.1 Единицы em и rem
__em__ - это мера, использовавшаяся изначательно в полиграфии и ссылающаяся на определённый размер шрифта. В CSS 1 em означает размер шрифта текущего элемента, его точное значение варьируется в зависимости от того, к какому элементу вы его применяете.

```CSS
 .padded {
	 font-size: 16px;
	 padding: 1em; // Устанавливает отступы со всех сторон равные размеру шрифта (16px)
 }
```

Использовать единицу `em` удобно при настройке таких свойств, как `padding`, `height`, `width` или `border-radius`, поскольку они могут масштабироваться равномерно с элементом, если он наследует различные размеры шрифта или пользователь изменяет настройки шрифта.

__rem__ - Это сокращение от root em. Единицы rem относительны по отношению не к текущему элементу, а к корневому. 

__Корневой узер__ - это предок всех осталььных элементов документа. У него есть особый селектор псевдокласса `:root`, который испоьлзуется для его назначения. Этот приём эквивалентен задействованию селектора типа `html` со специфиностью класса, а не тега.

### Доступность

__Используйте относительные единицы для задания размера шрифта.__ Нажатием сочетания клавиш `CTRL +` или `CTRL -` пользователь может увеличить или уменьшить размер страницы. Это __визуально__ меняет масштаб всех шрифтов и изображений и в целом делает контент на странице больше или меньше. 

Изменение размера шрифта по умолчанию несколько отличается от предыдущего способа. Подвох в том, что эта настройка не меняет размер шрифтов, определенных в пикселях или других абсолютных единицах. Поскольку размер шрифта по умолчанию крайне важен для некоторых пользователей, особенно тех, кто имеет недостатки зрения, всегда следует указывать размеры шрифта в относительных единицах или процентах.

### Примеры использования

##### Пример 1

```CSS
 :root {
	 font-size: 0.625em; // 10px
 }
```

__Автор книги не советует так делать.__ Поначалу это может быть удобно, это практика упрощает вычисление: если дизайнер говорит, что нужно сделать шрифт размером 14 пикселей, вы в уме делите это число на 10 и задаете 1.4rem. Но данного подхода есть проблемы:
- Первая проблема - приходится писать много повторяющихся стилей. Десять пикселей - это слишком мало для большинства текстового контента, поэтому придётся переопределять его по всей странице.
- Вторая проблема - в том, что, делая это, вы продолжаете мыслить в пикселах. В адаптивном дизайне нужно освоиться с нечёткими значениями. Неважно, чему равны 1.2em, нужно знать лишь, что это немного больше наследуемого шрифта. И если на экране все выгрядит не так, как хочется, следует поменять значение. Делается это методом проб и ошибок, но то же самое происходит и при работе с пикселями. (В главе 13 этот подходит расматривается подробнее).

__Следует указать размер шрифта используемый по умолчанию в дизайне__. Предположим, можно установить размер шрифта, по умолчанию равный 14 пикселам. 

```CSS 
:root {
	font-size: 0.875em; // 14px
}
```

Теперь желаемый размер шрифта применен ко всей странице. Нам не придётся указывать его где-то ещё. Нужно будет только менять его так, где дизайн отклоняется от данного значения, например в заголовках.

##### Пример 2 

Можно задействовать медиазапросы для изменения базового размера шрифта в соответствии с размером экрана.

```CSS
:root {
	font-size: 0.75em;
}

@media (min-width: 800px) {
	:root {
		font-size: 0.875px
	}
}

@media (min-width: 1200px) {
	:root {
		font-size: 1em;
	}
}
```

Применяя этот подход, мы адаптивно переопределяем значение единиц `em` и `rem` на всей странице. Это означает, что страница теперь адаптивна, несмотря на то что мы напрямую не вносили в нее никаких изменений.

##### Пример 3

Можно использовать единицы `em` также для масштабирования отдельно взятого компонента на странице.  Сначала необходимо добавить объявление ожидаемого размера шрифта к родительскому элементу. Затем переопределим размер шрифта заголовка, применив единицы `em` вместо `rem`, чтобы сделать изменение выполняющимся относительно родительского размера шрифта.

```CSS
	.panel {
		font-size: 1rem;
		padding: 1em;
		border: 1px solid #999;
		border-radius: 0.5em;
	}

	.panel > h2 {
		margin-top: 0;
		font-size: 0.8em;  
		font-weight: bold;
		text-transform: uppercase;
	}
```

Это изменение никак не влияет на внешний вид панели, но подталкивает вас создать увеличенную версию панели всего одной строкой CSS. Всего илшь нужно переопределить родительский размер элемента `1rem` в другое значение.

```CSS
 .panel.large {
	 font-size: 1.2em;
 }
```

Теперь можно использовать код `class="panel"` для панели средного размера и `class="panel large"` для большой. Если панель будет представлять собой более сложный компонент с различными размерами шрифта или отступами, по-прежнему потребуется лишь одно это объявление, чтобы изменить размер, в то время как все, что находится внутри нее, будет определяться с помощью единиц `em`.


### 2.2 Единицы измерения, относящиеся к размеру экрана устройства.

```
Viewport (область просмотра) - ограниченная область в окне браузера, где отображаестя веб-страница, за исключением адресной строки, панели инструментов и панели текущего состояния, если она есть.
```

- `vh` - 1/100 высоты области просмотра
- `vw` - 1/100 ширины области просмотра
- `vmin` - 1/100 наименьших высоты или ширины
- `vmax` - 1/100 наибольших высоты или ширины

#### Единица wv для указания размера шрифта

```CSS
:root {
	font-size: calc(0.5em + 1vw);
}
```

Теперь можно наблюдать как шрифт плавно подстраивается под окно браузера. В качестве своего рода минимального размера шрифта здесь выступает `0.5em`, а `1vw` добавляет гибкую скалярную величину. Это даст нам основной размер шрифта, который меняется от `11.75px` на Iphone 6 до `20px` в окне браузера размером `1200px`.

Теперь мы реализовали большую часть своей адаптивной стратегии без единого медиазапроса.

### 2.3 Числа без единиц измерения и свойство line-height

Некоторые свойства допускают указание значений _без единиц измерения_. К ним относятся `line-height`, `z-index` и `font-weight`. Так же можно задействовать значение 0 без единиц измерения везде, где требуется единицы длины, потому что в таких случаях единиц неважна.

```
Ноль без единиц измерения используется только для значений длины и процентов, например, для настройки отступов, границ и ширины. Его нельня использовать с угловыми величинами, такими как градусы, или временными значениями, такими как секунды.
```

```CSS
body {
	line-height: 1.2;
}

.about-us {
	font-size: 2em;
}
```

Свойство `line-height` необычно тем что, что позволяет как использовать единицы измерения, так и не использовать. Но стоит применять числа без единиц, поскольку они наследуются по-другому. Если задать `line-height`, указав единицы измерения, то, возможно, можно столкнуться с непредвиденным результатом строки текста начнут наползать одна на другую.



### 2.4 Пользовательские свойства (или CSS-переменные)

__Определение пользовательского свойства__
```CSS
:root {
	--main-font: Helvetica, Arial, sans-serif;
}
```

Функция `var()` позволяет использовать переменные.
```CSS
body {
 font-size: var(--main-font);
}
```

Функция `var()` принимает второй параметр, который задает резервное значение. Если переменная, указанная в первом параметре, не определена, используется второе значение.

```CSS
body {
	font-size: var(--main-font, sans-serif);
	color: var(--main-color, blue);
}
```

```
Внимание !

Если функция var() имеет недопустимое значение, свойству будет присвоено его первоначальное значение. Например, так как переменная в коде padding: var(--brand-color) вычисляет цвет, это будет недопустимое значение отступа. В этом случае отступ будет установлен со значением 0.
```



