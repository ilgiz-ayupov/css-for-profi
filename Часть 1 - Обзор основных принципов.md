В Части 1 подробно рассматриваются наиболее важные составляющие CSS - __каскадность__, __относительные единицы__ и __блочная модель__. 

## Глава 1. Каскадность, специфичность и наследование.

__В этой главе:__
- Четыре компонента каскадности.
- Разница между каскадностью и наследованием.
- Управление стилями, применяемые к элементам.
- Распространенные недоразумения с сокращенными объявлениями.

### 1.1 Каскадность
__Каскадность CSS__ - это механизм, благодаря которому к HTML-документу может применяться более чем одно правило CSS. 

__Каскадное значение__ -  объявление, которое "побеждают"каскадность.

Правила могут исходить из различных источников: из внешней и внутренней таблицы стилей, от механизма наследования, от родительских элементов, от классов и ID, от селектора тега, от атрибута `style` и т.д. 

Когда правила конфликтуют, для устранения проблемы нужно учесть три показателя.
1. `Источник стилей` - место их разположения. Ваши стили накладываюся на стили браузера, применяемые по умолчанию.
2. `Специчность селекторов` - то, какие селекторы имеют приоритет над другими.
3. `Исходный порядок` - порядок, в котором стили объявляются в таблице стилей.

#### 1.1.1 Источник стилей
Источники стилей:
1. `Браузерные` - созданные браузером таблицы стилей
2. `Авторские` - созданные вами таблицы стилей

#### 1.1.2 Специфичность селекторов
__Браузер оценивает специфичность в два этапа__:
1. `Встроенные в HTML-код (Inline-стили)` - объявления, задаваемые в вашей таблице стилей или теге `<style>`. Во встроенных стилях нет селектора, потому что они действуют непосредственно на сам элемент.
	```html
	<li>
		<a href="/specials" class="featured" style="background-color: orange;">
		Акции !
		</a>
	</li>
	```
1. `Стили, применяемые с помощью селекторов` - __специфичность селекторов__.

__Примечание__:
 - __Селекторы псевдоклассов__ (например, `:hover`) и __селекторы атрибутов__ (например, `[type="input"]`) специфичны в той же степени, что и селектор класса. __Универсальный селектор (`*`) и комбинаторы (`>, +, ~`) не влияют на специфичность__.
	 
__Система приоритов:__

#### 1.1.3 Исходный порядок

- Порядок имеет значение: стили, указанные позже, переоределяют ранние стили с той же специфичностью. Если два подобных стиля или более одновременно относятся к одному и тому же элементу, __последний__ переопределяет предыдущие. 

##### - Правильное форматирование ссылок:

```CSS
	a:link { // Непосещенная
		color: blue;
		text-decoration: none;
	}

	a:visited {  // Посещенная
		color: purple;	
	}

	a:hover { // Наведение
		text-decoration: underline;
	}

	a:active { // Активная
		color: red;
	}
```

#### 1.1.4 Два правила каскадности

1. _Не используйте идентификаторы в селекторе_. Даже один идентификатор усиливает специфичность. Когда требуется переопределить селектор, может не оказаться другого идентификатора, который реально задействавать, поэтому вам придётся скопировать исходный селектор и добавить другой класс, чтобы отличить его от того, который вы пытаетесь переопределить.
2. _Не используйте аннотацию !important_. Её ещё труднее переопределить, чем идентификатор, и, как только вы её примените, нужно будет добавлять её каждый раз, когда захотите переопределить исходное объяление, и тогда все равно придётся иметь дело со специфичностью.

### Ключевое слово important
Объявление со словом !important рассмотривается как источник с более высоким приоритетом. Далее стили перечислены в порядке убывания приоритета.
1. Важные авторские стили.
2. Авторские стили
3. Браузерные стили

### Немного про JavaScript
Создавая модуль JavaScript для последующего распространения (например, пакет NPM), __не задействуйте стили, встроенные в JavaScript__, когда этого можно избежать. Если вы это сделаете, разработчики, применяющие вам пакет, будут вынуждены либо принять ваши стили без изменений, либо использовать аннотацию !important для каждого свойства, которое она захотят изменить.

Вместо этого добавьте в пакет таблицу стилей. Если ваш компонент должен динамически менять стили,  почти всегда предпочтительнее задействовать JavaScript для добавления и удаления классов элементов. Кроме того, пользователи смогут отредактировать таблицк стилей как им нравится, не сталкиваясь с конфликтами специфичности.

### 1.2 Наследование
__Наследование в CSS__ - это механизм, с помощью которого значения свойств элемента-родителя передаются его элементам-потомкам.


### 1.3 Специальные значения

#### 1.3.1 Ключевое слово inherit
Позволяет унаследовать стиль, когда каскадное значение замещает его.

#### 1.3.2 Ключевое слово initial 
Позволяет сбросить стили у элемента, приводя их к значению по умолчанию.

__Примечание__
-   Объявление `dispay: initial` эквивалентно коду `dispay: inline`. Оно не будет определено как `display: block` независимо от того, к элементу какого типа вы его применяете. Это потому, что ключевое слово initial выполняет сброс до начального значения для свойства, а не элемента, а `inline` - значение по умолчанию для свойства `display`.


### 1.4 Сокращенная запись свойств
__Сокращенная запись свойств__ - это присвоение значений нескольких свойств одновременно.

- `background` - сокращенная запись свойств фона `background-color`, `background-image`, `background-size`, `background-repeat`, `background-position`, `background-origin`, `background-chip` и `background-attachment`.
- `border` - сокращенная запись свойств `border-width`, `border-style` и `border-color`
- `border-width` - сокращенная запись свойств `top`, `right`, `bottom` и `left` ширины границ.

__Внимание !__
- Большинство сокращенниый записей свойств позволяют опускать определенные значения и указывать только нужные. Однако важно знать, что пропущенные свойства все равно задаются - им присваивается начатьные значения.

### 1.4.1 Порядок записи сокращенных значений
- По часовой стрелке - применяется для `margin`, `padding` и некоторых свойств границ, которые определяют значения для каждой из четырёх сторон элементов.
- Горизонтально, вертикально - описывает `x`  и `y` кординаты элемента