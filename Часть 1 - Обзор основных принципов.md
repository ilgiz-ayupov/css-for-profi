В Части 1 подробно рассматриваются наиболее важные составляющие CSS - __каскадность__, __относительные единицы__ и __блочная модель__. 

## Глава 1. Каскадность, специфичность и наследование.

__В этой главе:__
- Четыре компонента каскадности.
- Разница между каскадностью и наследованием.
- Управление стилями, применяемые к элементам.
- Распространенные недоразумения с сокращенными объявлениями.

### 1.1 Каскадность
__Каскадность CSS__ - это механизм, благодаря которому к HTML-документу может применяться более чем одно правило CSS. 

__Каскадное значение__ -  объявление, которое "побеждают"каскадность.

Правила могут исходить из различных источников: из внешней и внутренней таблицы стилей, от механизма наследования, от родительских элементов, от классов и ID, от селектора тега, от атрибута `style` и т.д. 

Когда правила конфликтуют, для устранения проблемы нужно учесть три показателя.
1. `Источник стилей` - место их разположения. Ваши стили накладываюся на стили браузера, применяемые по умолчанию.
2. `Специчность селекторов` - то, какие селекторы имеют приоритет над другими.
3. `Исходный порядок` - порядок, в котором стили объявляются в таблице стилей.

#### 1.1.1 Источник стилей
Источники стилей:
1. `Браузерные` - созданные браузером таблицы стилей
2. `Авторские` - созданные вами таблицы стилей
3. `Пользовательские свойства` - CSS переменные

#### 1.1.2 Специфичность селекторов
__Браузер оценивает специфичность в два этапа__:
1. `Встроенные в HTML-код (Inline-стили)` - объявления, задаваемые в вашей таблице стилей или теге `<style>`. Во встроенных стилях нет селектора, потому что они действуют непосредственно на сам элемент.
	```html
	<li>
		<a href="/specials" class="featured" style="background-color: orange;">
		Акции !
		</a>
	</li>
	```

2. Стили, применяемые с помощью селекторов - __специфичность селекторов__.

__Примечание:__

Селекторы псевдоклассов(например, `:hover`) и селекторы атрибутов (например, `[type="input"]`) специфичны в той же степени, что и селектор класса. Универсальный селектор (`*`) и комбинаторы (`>`,  `+`, `~`) не влияют на специфичность.

__Система приоритов:__

| Селектор     | Вес |
| ------------ | --- |
| Тег          | 1   |
| Класс        | 10  |
| ID           | 100 |
| Inline-стили | 1000    |

__Когда селектор состоит из нескольких других селекторов, необходимо посчитать их общий вес__

#### 1.1.3 Исходный порядок

__Порядок имеет значение:__ стили, указанные позже, переоределяют ранние стили с той же специфичностью. Если два подобных стиля или более одновременно относятся к одному и тому же элементу, последний переопределяет предыдущие. 

##### - Правильное форматирование ссылок:

```CSS
	a:link { // Непосещенная
		color: blue;
		text-decoration: none;
	}

	a:visited {  // Посещенная
		color: purple;	
	}

	a:hover { // Наведение
		text-decoration: underline;
	}

	a:active { // Активная
		color: red;
	}
```

#### 1.1.4 Два правила каскадности

1. _Не используйте идентификаторы в селекторе_. Даже один идентификатор усиливает специфичность. Когда требуется переопределить селектор, может не оказаться другого идентификатора, который реально задействавать, поэтому вам придётся скопировать исходный селектор и добавить другой класс, чтобы отличить его от того, который вы пытаетесь переопределить.
2. _Не используйте аннотацию !important_. Её ещё труднее переопределить, чем идентификатор, и, как только вы её примените, нужно будет добавлять её каждый раз, когда захотите переопределить исходное объяление, и тогда все равно придётся иметь дело со специфичностью.

### Ключевое слово important
Объявление со словом !important рассмотривается как источник с более высоким приоритетом. Далее стили перечислены в порядке убывания приоритета.

### Немного про JavaScript
Создавая модуль JavaScript для последующего распространения (например, пакет NPM), __не задействуйте стили, встроенные в JavaScript__, когда этого можно избежать. Если вы это сделаете, разработчики, применяющие ваш пакет, будут вынуждены либо принять ваши стили без изменений, либо использовать аннотацию !important для каждого свойства, которое она захотят изменить.

Вместо этого добавьте в пакет таблицу стилей. Если ваш компонент должен динамически менять стили,  почти всегда предпочтительнее задействовать JavaScript для добавления и удаления классов элементов. Кроме того, пользователи смогут отредактировать таблицу стилей как им нравится, не сталкиваясь с конфликтами специфичности.

### 1.2 Наследование
__Наследование в CSS__ - это механизм, с помощью которого значения свойств элемента-родителя передаются его элементам-потомкам.


### 1.3 Специальные значения

#### 1.3.1 Ключевое слово inherit
Позволяет унаследовать стиль, когда каскадное значение замещает его.

#### 1.3.2 Ключевое слово initial 
Позволяет сбросить стили у элемента, приводя их к значению по умолчанию.

__Примечание__
-   Объявление `dispay: initial` эквивалентно коду `dispay: inline`. Оно не будет определено как `display: block` независимо от того, к элементу какого типа вы его применяете. Это потому, что ключевое слово initial выполняет сброс до начального значения для свойства, а не элемента, а `inline` - значение по умолчанию для свойства `display`.


### 1.4 Сокращенная запись свойств
__Сокращенная запись свойств__ - это присвоение значений нескольких свойств одновременно.

- `background` - сокращенная запись свойств фона `background-color`, `background-image`, `background-size`, `background-repeat`, `background-position`, `background-origin`, `background-chip` и `background-attachment`.
- `border` - сокращенная запись свойств `border-width`, `border-style` и `border-color`
- `border-width` - сокращенная запись свойств `top`, `right`, `bottom` и `left` ширины границ.

__Внимание !__
- Большинство сокращенных записей свойств позволяют опускать определенные значения и указывать только нужные. Однако важно знать, что пропущенные свойства все равно задаются - им присваивается начатьные значения.

### 1.4.1 Порядок записи сокращенных значений
- По часовой стрелке - применяется для `margin`, `padding` и некоторых свойств границ, которые определяют значения для каждой из четырёх сторон элементов.
- Горизонтально, вертикально - описывает `x`  и `y` кординаты элемента


## Глава 2. Работа с относительными единицами

__В этой главе__:
- Гибкость относительных единиц
- Как использовать единицы: rem и em
- Применение экранных единиц: vw и vh
- Введение в CSS переменные

### 2.1 Единицы em и rem
__em__ - это мера, использовавшаяся изначательно в полиграфии и ссылающаяся на определённый размер шрифта. В CSS 1 em означает размер шрифта текущего элемента, его точное значение варьируется в зависимости от того, к какому элементу вы его применяете.

```CSS
 .padded {
	 font-size: 16px;
	 padding: 1em; // Устанавливает отступы со всех сторон равные размеру шрифта (16px)
 }
```

Использовать единицу `em` удобно при настройке таких свойств, как `padding`, `height`, `width` или `border-radius`, поскольку они могут масштабироваться равномерно с элементом, если он наследует различные размеры шрифта или пользователь изменяет настройки шрифта.

__rem__ - Это сокращение от `root em`. Единицы rem относительны по отношению не к текущему элементу, а к корневому. 

__Корневой узер__ - это предок всех остальных элементов документа. У него есть особый селектор псевдокласса `:root`, который используется для его назначения. Этот приём эквивалентен задействованию селектора типа `html` со специфиностью класса, а не тега.

#### Доступность

__Используйте относительные единицы для задания размера шрифта.__ Нажатием сочетания клавиш `CTRL +` или `CTRL -` пользователь может увеличить или уменьшить размер страницы. Это __визуально__ меняет масштаб всех шрифтов и изображений и в целом делает контент на странице больше или меньше. 

Изменение размера шрифта по умолчанию несколько отличается от предыдущего способа. Подвох в том, что эта настройка не меняет размер шрифтов, определенных в пикселях или других абсолютных единицах. Поскольку размер шрифта по умолчанию крайне важен для некоторых пользователей, особенно тех, кто имеет недостатки зрения, всегда следует указывать размеры шрифта в относительных единицах или процентах.

### Примеры использования

##### Пример 1

```CSS
 :root {
	 font-size: 0.625em; // 10px
 }
```

__Автор книги не советует так делать.__ Поначалу это может быть удобно, это практика упрощает вычисление: если дизайнер говорит, что нужно сделать шрифт размером 14 пикселей, вы в уме делите это число на 10 и задаете 1.4rem. Но данного подхода есть проблемы:
- Первая проблема - приходится писать много повторяющихся стилей. Десять пикселей - это слишком мало для большинства текстового контента, поэтому придётся переопределять его по всей странице.
- Вторая проблема - в том, что, делая это, вы продолжаете мыслить в пикселах. В адаптивном дизайне нужно освоиться с нечёткими значениями. Неважно, чему равны 1.2em, нужно знать лишь, что это немного больше наследуемого шрифта. И если на экране все выгрядит не так, как хочется, следует поменять значение. Делается это методом проб и ошибок, но то же самое происходит и при работе с пикселями. (В главе 13 этот подходит расматривается подробнее).

__Следует указать размер шрифта используемый по умолчанию в дизайне__. Предположим, можно установить размер шрифта, по умолчанию равный 14 пикселам. 

```CSS 
:root {
	font-size: 0.875em; // 14px
}
```

Теперь желаемый размер шрифта применен ко всей странице. Нам не придётся указывать его где-то ещё. Нужно будет только менять его там, где дизайн отклоняется от данного значения, например в заголовках.

##### Пример 2 

Можно задействовать медиазапросы для изменения базового размера шрифта в соответствии с размером экрана.

```CSS
:root {
	font-size: 0.75em;
}

@media (min-width: 800px) {
	:root {
		font-size: 0.875px
	}
}

@media (min-width: 1200px) {
	:root {
		font-size: 1em;
	}
}
```

Применяя этот подход, мы адаптивно переопределяем значение единиц `em` и `rem` на всей странице. Это означает, что страница теперь адаптивна, несмотря на то что мы напрямую не вносили в нее никаких изменений.

##### Пример 3

Можно использовать единицы `em` также для масштабирования отдельно взятого компонента на странице.  Сначала необходимо добавить объявление ожидаемого размера шрифта к родительскому элементу. Затем переопределить размер шрифта заголовка, применив единицы `em` вместо `rem`, чтобы сделать изменение выполняющимся относительно родительского размера шрифта.

```CSS
	.panel {
		font-size: 1rem;
		padding: 1em;
		border: 1px solid #999;
		border-radius: 0.5em;
	}

	.panel > h2 {
		margin-top: 0;
		font-size: 0.8em;  
		font-weight: bold;
		text-transform: uppercase;
	}
```

Это изменение никак не влияет на внешний вид панели, но подталкивает вас создать увеличенную версию панели всего одной строкой CSS. Всего лишь нужно переопределить родительский размер элемента `1rem` в другое значение.

```CSS
 .panel.large {
	 font-size: 1.2em;
 }
```

Теперь можно использовать код `class="panel"` для панели средного размера и `class="panel large"` для большой. Если панель будет представлять собой более сложный компонент с различными размерами шрифта или отступами, по-прежнему потребуется лишь одно это объявление, чтобы изменить размер, в то время как все, что находится внутри нее, будет определяться с помощью единиц `em`.


### 2.2 Единицы измерения, относящиеся к размеру экрана устройства.

```
Viewport (область просмотра) - ограниченная область в окне браузера, где отображаестя веб-страница, за исключением адресной строки, панели инструментов и панели текущего состояния, если она есть.
```

- `vh` - 1/100 высоты области просмотра
- `vw` - 1/100 ширины области просмотра
- `vmin` - 1/100 наименьших высоты или ширины
- `vmax` - 1/100 наибольших высоты или ширины

#### Единица wv для указания размера шрифта

```CSS
:root {
	font-size: calc(0.5em + 1vw);
}
```

Теперь можно наблюдать как шрифт плавно подстраивается под окно браузера. В качестве своего рода минимального размера шрифта здесь выступает `0.5em`, а `1vw` добавляет гибкую скалярную величину. Это даст нам основной размер шрифта, который меняется от `11.75px` на Iphone 6 до `20px` в окне браузера размером `1200px`.

Теперь мы реализовали большую часть своей адаптивной стратегии без единого медиазапроса.

### 2.3 Числа без единиц измерения и свойство line-height

Некоторые свойства допускают указание значений _без единиц измерения_. К ним относятся `line-height`, `z-index` и `font-weight`. Так же можно задействовать значение 0 без единиц измерения везде, где требуется единицы длины, потому что в таких случаях единицы неважны.

```
Ноль без единиц измерения используется только для значений длины и процентов, например, для настройки отступов, границ и ширины. Его нельня использовать с угловыми величинами, такими как градусы, или временными значениями, такими как секунды.
```

```CSS
body {
	line-height: 1.2;
}

.about-us {
	font-size: 2em;
}
```

Свойство `line-height` необычно тем что, что позволяет как использовать единицы измерения, так и не использовать. Но стоит применять числа без единиц, поскольку они наследуются по-другому. Если задать `line-height`, указав единицы измерения, то, возможно, можно столкнуться с непредвиденным результатом строки текста начнут наползать одна на другую.



### 2.4 Пользовательские свойства (или CSS-переменные)

__Определение пользовательского свойства__
```CSS
:root {
	--main-font: Helvetica, Arial, sans-serif;
}
```

Функция `var()` позволяет использовать переменные.
```CSS
body {
 font-size: var(--main-font);
}
```

Функция `var()` принимает второй параметр, который задает резервное значение. Если переменная, указанная в первом параметре, не определена, используется второе значение.

```CSS
body {
	font-size: var(--main-font, sans-serif);
	color: var(--main-color, blue);
}
```

__Внимание !__

Если функция `var()` имеет недопустимое значение, свойству будет присвоено его первоначальное значение. Например, так как переменная в коде `padding: var(--brand-color)` вычисляет цвет, это будет недопустимое значение отступа. В этом случае отступ будет установлен со значением 0.

## Глава 3. Знакомство с блочной моделью

__В этой главе:__
- Практический совет по установке размеров элементов и их позиционированию по странице.
- Вертикальное центрирование.
- Колонки равной высоты.
- Отрицательные значения полей, схлопывание полей.
- Согласованное расстояние между компонентами на странице.

### 3.1 Трудности с шириной элемента
- `box-sizing` - это свойство, которое управляет блочной моделью
	- `content-box` - значение. которое стоит по умолчанию. Задаёт указанную высоту и ширину размером контента. Такие свойства как, `padding`, `border` будут накладываться на контент увеличивая его.
	- `border-box` - значение, котороё задаёт высоту и ширину, отступы и границы как сумарный размер контента.

 __Более надёжное применение значения `border-box`__
```CSS
:root {
	box-sizing: border-box;
}

*,
::before,
::after {
 box-sizing: inherit;
}
```

Свойство `box-sizing` обычно не наследуется, но, используя ключевое слово `inherit`, мы можем заставить его быть таковым

#### 3.1 Добавление зазора между колонками

```CSS
.sidebar {
	width: calc(30% - 1.5em);
	margin-left: 1.5em;
}
```

####   3.2 Проблема высоты элементов.

##### Управление переполнение
- `overflow` - свойство, которое позволяет точно управлять поведением переполняющего контента.
	- `visible` (значение по умолчанию) - весь контент отображается, даже если выходит за края контента;
	- `hidden` - контент вне контейнера будет скрыт;
	- `scroll` - в контейне добавляются полосы прокрутки, чтобы пользователь мог увидеть оставшийся контент.
	- `auto` - полосы прокрутки добавляются в контейнер только при переполнении контентом.
- Используя свойство `overflow-x` или `overflow-y` можно управлять только горизонтальным или вертикальным свойством.

##### Свойтва min-height и max-height
Два свойства, которые могут оказаться чрезвычайно полезными. Вместо того чтобы явно определять высоту, можно использовать из для указания минимального или максимального значения, позволяющего элементу естественным образом варьироваться в пределах данного диапазона. Аналогичные свойства `min-width`  и `max-width` ограничивают ширину элемента.

##### Центрирование контента по вертикали.
`vertical-align` - свойство, влияет только на строчные и табличные элементы. В случае со строчными элементами оно контролирует выравнивание между элементами в одной строке. Например, вы можете использовать его для управления тем, как строчное изображение выравнивается с соседним текстом.

__Руководство по вертикальному центрированию__
1. Установить одиновые верхние и нижние отступы.
2. Flexbox - если не нужна поддержка Internet Explorep 9.
3. Line-height - при работе с однострочным текстом.
4. Абсолютное позиционирование - если вы знаете высоту контейнера и внутреннего контента
5. Абсолютное позиционирование + трансформация - если вы не знаете высоту контейнера и внутреннего контента

#### 3.3 Отрицательные значения внешних отступов (margin).

Этот способ удобен, например, когда элементы должны перекрывать друг друга или иметь большую ширину, чем содержащие их контейнеры.

__Отрицательные margin-top или margin-bottom__

```CSS
.box {
  width: 30px;
  height: 30px;
}

.box1 {
  background: red;
}

.box2 {
  background: blue;
  margin-top: -10px;
}

.box3{
  background: yellow;
}
```

Второй блок перекроет первый, третий блок тоже поднимется вверх за  вторым блоком.

__Отрицательные margin-left и margin-top__

```CSS
.container {
	max-width: 800px;
}

.content {
	margin-left: -15px;
	margin-right: -15px;
}
```

Когда блочный элемент не имеет указанной ширины, он, естественно, заполняет ширину своего родителя. Отрицательные значения `margin-left` и `margin-right` могут изменить это позволяя контенту выходить за рамки контейнера.

#### 3.4 Схлопывание внешних отступов.
__Источник__: https://habr.com/ru/post/465839/

Когда верхнее и/или нижнее `margin` прилегают друг к другу, они перекрываются, объединяясь для формирования единого поля. Это называется _схлопыванием_.

__Margin схлопывается в следующих ситуациях__
- Смежные сестринские элементы (имеющие одного родителя)
- Пустые блоки
- Родитель и первый/ последний дочесний элемент

##### Смежные сестринские элементы

```HTML
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div class="content">
    <div class="box box1"></div>
    <div class="box box2"></div>
    <div class="box box3"></div>  
  </div>
</body>
</html>
```

```CSS
.box {
  height: 100px;
}

.box1 {
  background: red;
  margin: 50px 0;
}

.box2 {
  background: blue;
  margin: 20px 0;
}

.box3 {
  background: yellow;
  margin: 3em 0;
}
```

Представлены три `div` элемента. У первого элемента `margin-top` и `margin-bottom` равны `50px`, у второго - `20px`, у третьего - `3em`.  `Margin` мужду первыми элементы получается `50px`, так как меньший `margin` нижнего элемента поглащается большим `margin` верхнего элемента. `Margin` между вторыми двумя элементами получается `3em`, так как `3em` больше, чем `20px` у нижнего `margin` второго элемента.

##### Пустые блоки

Если блок пустой, его верхний и нижний `margin` могут схлопываться друг с другом. 

```CSS
.content {
	margin: 50px 0;
}
```

Блок `.content` имеет верхний и нижний `margin` по `50px`, однако, пространство равняется не `100px`, а `50px`. 

Добавление чего-либо в блок границ ( `border`) или внутренних отступов (`padding`) приведевет к тому, что верхний и нижний margin будут использоваться, а не схлопываться.

```CSS
.content {
	margin: 50px 0;
	border: 1px solid #000;
}
```

```CSS
.content {
	margin: 50px 0;
	padding: 20px 0;
}
```

##### Родительский и первый/ последний дочерний элемент

```HTML
 <div class="wrapper">
    <div class="content"> 
      <div class="box">item 1</div>
      <div class="box">Item 2</div>
      <div class="box">Item 3</div>
    </div>
  </div>
```

```CSS
.wrapper {
  margin: 5em;
}

.content {
  outline: 1px solid red;
}

.box {
  margin: 50px;
  padding: 20px;
  color: white;
  background: blue;
  border-radius: 10px;
}
```

Блоку `.content` задаём свойтсво `ouline` для того, чтобы было видно его границы. Все три дочерних элемента `.box` имеют `margin: 50px`. Тем не менее, первый и последний элементы примыкают к границам элемента `.content`; нет отступа в `50px` между `.box` и `.content`.

Это проиходит потому, что `margin` дочернего элемента схлопывается с любым `margin` родителя таким образом, что заканчивается за пределами родителя.

![[Pasted image 20221220010151.png]]

__Предотвратить данное схлопывание можно применив свойтво__ `overflow: auto;` Блоку `.content`

```CSS
.content {
	outline: 1px solid red;
	overflow: auto;
}
```

##### Схлопываются только margin

С CSS 2 только вертикальные (верхний и нижний) `margin` были расчитаны на схлопывание. Поэтому на примере выше `margin` слева и справа не схлопываются и заканчиваются внутри обертки.

```
Margin не схлопываются, если элементу задано абсолютное позиционирование или свойство `float`.
```

##### Flex и Grid-контейнеры

Flex и Grid-контейнеры уставливают Flex и Grid контекст форматирования для дочерних элементов, поэтому у них разное поведение блочной разметки. Одно из этих отличий заключается в  том, что `margin` не схлопываются.

Если мы возьмём пример выше и сделаем обёртку Flex-контейнером, указав направление главной оси `flex-direction: column;`, станет понятно, что теперь `margin`  дочерних элементов не выходят за рамки `.content`. Дополнительно, `margin` между смежными flex-элементами не схлопываются, поэтому мы получаем расстояние в `100px` между flex-элементами, что является суммой верхнего и нижнего `margin`, которые равны `50px`

```CSS
.content {
  outline: 1px solid red;
  display: flex;
  flex-direction: column;
}

.box {
  margin: 50px;
  padding: 20px;
  color: white;
  background: blue;
  border-radius: 10px;
}
```

#### 3.5 Растояние между элементами в контейнере

__Использование комбинатора для установки поля между кнопками__

```CSS
.button-link {
	display: block;
	padding: .5rem;
	color: white;
	background-color: #0090C9;
	text-transform: uppercase;
}

.button-link + .button-link {
	margin-top: 1.5em;
}
```

##### Универсальное решение: селектор лоботомированной совы

__Селектор лоботомированной совы__ выглядит так: `* + *` 

Это __универсальный селектор__ (`*`), который предназначен для всех элементов и за которым следует __комбинатор смежных элементов__, а затем ещё один универсальный селектор. Селектор получил такое название, потому что он похож на сову с пустым взглядом.

```CSS
body * + * {
	margin-top: 1.5em;
}
```

Селектор лоботомированной совы - это компромисс. Он упрощает обработку множества `margin` на всей странице, но вам придётся переопределить их в тех местах, где не нужно, чтобы они применялись, - обычно только так, где есть элементы, расположенные бок о бое, как в многоколоночном макете. В завасимости от дизайне необходимо также задать желаемые `margin` для абзацев и заголовков.
